{\rtf1\ansi\ansicpg1252\cocoartf1187
{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\ftech\fcharset77 Symbol;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;\red255\green0\blue0;\red0\green0\blue255;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{lower-alpha\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid601\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid701\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid801\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid901\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid10}
{\list\listtemplateid11\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1001\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid11}
{\list\listtemplateid12\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid12}
{\list\listtemplateid13\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid13}
{\list\listtemplateid14\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid14}
{\list\listtemplateid15\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid15}
{\list\listtemplateid16\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat0\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid16}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}{\listoverride\listid11\listoverridecount0\ls11}{\listoverride\listid12\listoverridecount0\ls12}{\listoverride\listid13\listoverridecount0\ls13}{\listoverride\listid14\listoverridecount0\ls14}{\listoverride\listid15\listoverridecount0\ls15}{\listoverride\listid16\listoverridecount0\ls16}}
{\info
{\title Bo Haglund}
{\author Bo Haglund}
{\*\company  }}\margl1417\margr1417\margb1417\margt1417\vieww12540\viewh16140\viewkind1
\deftab720
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://privat.bahnhof.se/wb758135/"}}{\fldrslt 
\f0\fs24 \cf2 \ul \ulc2 http://privat.bahnhof.se/wb758135/}}
\f0\fs24 \'a0
\f1 \
\pard\pardeftab1304
\cf0 Bo Haglund\
Rev. E4,  2010-04-09\
\pard\pardeftab1304

\b\fs28 \cf0 \
\
Search Algorithms for a Bridge Double Dummy Solver \
\pard\pardeftab1304

\b0\fs24 \cf0 \
This description is intended for anyone interested in the inner workings of a bridge double dummy solver (DDS). It describes my solver implemented in the Win32 environment as a DLL.  \
\
DDS algorithm descriptions already exist, see reference list at the end. However, to my knowledge, no document exists that gives an in depth description of all algorithms covered in this document.\
\
\
\
\
\pard\tx0\pardeftab1304
\ls1\ilvl0
\b \cf0 1.	The basic search algorithm\
\pard\pardeftab1304

\b0 \cf0 \
 The search is based on the zero window search [Pearl 1980]. \
 Pseudo code for its application on DD solver search is given.\
 Cards searched are described as \'94moves\'94 in contrast to cards that are really played.\page \
 int  Search(posPoint, target, depth) \{\
    if (depth==0) \{\
        tricks=Evaluate;\
        if  (tricks >= target) \
            value=TRUE;\
        else\
            value=FALSE;\
        return value;\
    \}\
    else \{\
        GenerateMoves;\
        if  (player_side_to_move) \{\
            value=FALSE;   moveExists=TRUE;\
            while (moveExists) \{\
                Make;\
                value=Search(posPoint, target, depth-1);\
                Undo;\
                if  (value==TRUE) \
 	goto searchExit;	/* Cutoff, current move recorded as \'94best move\'94 */\
                moveExists=NextMove;\
            \}\
        \}	/* Opponents to move */\
        else \{	    \
             value=TRUE;   moveExists=TRUE;\
             while (moveExists) \{\
                 Make;\
                 value=Search(posPoint, target, depth-1);\
                 Undo;\
                 if  (value==FALSE) \
 	goto searchExit;	/* Cutoff, current move recorded as \'94best move\'94 */\
                 moveExists=NextMove;\
             \}\
        \}\
    \}\
\
    searchExit:\
    return  value;\
\}\
\
\
The Search  parameters are:\
\pard\tx360\pardeftab1304\li360\fi-360
\ls2\ilvl0
\b \cf0 posPoint - 
\b0  a pointer to a structure containing state information for the position (deal) to be searched, e.g. leading hand,  hand-to-play, cards yet to play etc.\
\ls2\ilvl0
\b target
\b0  -  the number of tricks the player must take. \
\ls2\ilvl0
\b depth
\b0  -  the current search depth.\
\pard\pardeftab1304
\cf0 \
Search returns TRUE if the target is reached, otherwise FALSE.\
\
When Search is called, depth is set to the number of cards left to play minus 4. \
GenerateMoves generates a list of alternative moves (=cards) that can be played in the initial position whose state data is pointed to by posPoint. For cards that are equivalent (e.g. AK) only the card with highest rank is generated. Card equivalence is reanalyzed after each trick. \
E.g. if the hand-to-play has AQ in a suit where K was played in a previous trick, then A and Q become equivalents.\
\
If the side of the player has the move, Search tries to find a move that meets the target, i.e that evaluates to TRUE. If such a move is found, search returns TRUE, and saves the move as \'94best\'94.\
If the other side has the move, Search tries to find a move that defies meeting the target, i.e. that evaluates to FALSE. If such a move is found, search returns FALSE, and saves the move as \'94best\'94.\
\
Each move in the generated move list is handled by first calling Make, which removes the card from the position state information. Search is then recursively called with a position state that now has excluded the played card, depth has been decremented by one. For each new recursive call to Search, a card is removed from the position state information and depth is decremented. This goes on until depth equals 0 in which case only one trick remains. The outcome of this trick is calculated by Evaluate. If the total number of tricks won by the side of the player then reaches target, Search returns TRUE, otherwise FALSE. This result propagates upwards as Search returns for each level, Undo is called which reinstalls the searched card on this level.\uc0\u8232 Finally, Search returns for the top level.\
\
This basic search algorithm is not powerful enough to terminate the search of a typical 52 cards deal in a reasonable time. To accomplish this, a number of search algorithm enhancements are required, which will be described in the following chapters.  \
\page \
The described search algorithm only tells if a predefined target can be reached. It does not tell how many tricks that the side of the player can get. This is accomplished by repeated calls to Search:\
\
g = guessed number of tricks for side of the player\
iniDepth = number of cards to play minus 4\
upperbound = 13;\
lowerbound = 0;\
do  \{\
    if  (g==lowerbound)\
        tricks=g+1;\
    else\
        tricks=g;\
    if  ((Search(posPoint, tricks, iniDepth)==FALSE)  \{\
        upperbound=tricks-1;\
        g=upperbound;\
    \}\
    else  \{\
        lowerbound=tricks;\
        g=lowerbound;\
    \}\
\}\
while (lowerbound < upperbound);\
g=maximum tricks to be won by side of player.
\b \
\
\
\
\pard\tx0\pardeftab1304
\ls3\ilvl0\cf0 2.	Overview of the search algorithms used in the DD solver \
\pard\pardeftab1304
\cf0 \
\pard\pardeftab1304

\b0 \cf0 The additional functions in the pseudo code for supporting the search speed enhancements are given in 
\i italics
\i0 .  \
\page \
int  Search(posPoint, target, depth) \{\
      if (no_move_yet_in_trick)  \{\
          
\i TargetTooLowOrHigh;\

\i0           if (target_already_obtained)\
              return TRUE;\
          else if (target_can_no_longer_be_obtained)\
              return FALSE;
\i  \
          QuickTricks;\
          LaterTricks;\

\i0           if  (cutoff_for_player_side) \
             return TRUE;\
          else if  (cutoff_for_opponent_side)\
             return FALSE;
\i \uc0\u8232           RetrieveTTresult;\

\i0           if (transposition_table_entry_match) \{\
\pard\pardeftab1304

\i \cf0              
\i0 if  (target_reached)\
                return TRUE;\
            else\
                return FALSE;\
         \}
\i \
\pard\pardeftab1304

\i0 \cf0      \}\
\
      if (depth==0) \{\
          
\i evalRes=Evaluate;\

\i0           if  (evalRes.tricks >= target) \
             value=TRUE;\
         else\
             value=FALSE;\
         return value;\
      \}\
      else \{\
          GenerateMoves; \
\pard\pardeftab1304

\i \cf0           MoveOrdering;\
          CheckMovesForCutoff;   
\i0 /* For pseudo-code, see chapter 6 */
\i   \
\pard\pardeftab1304

\i0 \cf0           if  (player_side_to_move) \{\
              value=FALSE;    moveExists=TRUE;\
              while (moveExists) \{\
                 Make;\
                 value=Search(posPoint, target, depth-1);	\
                 Undo;\
                 if  (value==TRUE)  \{\
	
\i MergeMoveData;
\i0  
\i \

\i0  	goto searchExit;	/* Cutoff, current move recorded as \'94best move\'94 */\
                 \}\
                 
\i MergeAllMovesData;\

\i0                  moveExists=
\i NextMove
\i0 ;\
             \}\
         \}	/* Opponents to move */\
         else \{	    \
             value=TRUE;   moveExists=TRUE;\
             while (moveExists) \{\
                 Make;\
                 value=Search(posPoint, target, depth-1);	\
                 Undo;\
                 if  (value==FALSE)  \{ \
	
\i MergeMoveData;
\i0 \
 	goto searchExit;	/* Cutoff, current move recorded as \'94best move\'94 */\
                 \}\
\pard\pardeftab1304

\i \cf0                  MergeAllMovesData;
\i0 \
                 moveExists=
\i NextMove
\i0 ;\
             \}\
         \}\
     \}\
     searchExit:\
     
\i AddNewTTentry;\
\pard\pardeftab1304

\i0 \cf0      return  value;\
 \}\
\
\
\pard\pardeftab1304

\i \cf0 TargetTooLowOrHigh 
\i0  checks the target value against the number of tricks currently won by      side of the player and against number of tricks left to play.\
It is executed at the beginning of each trick, before any card has been played.\
If number of currently won tricks by player\'92s side equals or exceeds target, Search returns TRUE.\uc0\u8232 If number of currently won tricks by player\'92s side plus tricks left to play is less than target Search returns FALSE.\
Since possible winning cards for the remaining tricks are irrelevant, no winning cards are backed up at cutoff termination.\
\

\i TargetTooLowOrHigh 
\i0  search enhancement is described e.g. in [Chang].\
\

\i QuickTricks
\i0  determines if the side to move can take one or more sure tricks. E.g. if the hand to move has an Ace in an NT contract, at least one sure trick can be taken.\
It is executed at the beginning of each trick, before any card has been played. A simple quick trick is also executed after the leading card of the trick is played.\
Assuming that the sure tricks are won by the side to move, then the conditions for search cutoff in 
\i TargetTooLowOrHigh
\i0  are again tested to produce further search cutoffs.\
The detailed conditions for determination of sure tricks are described in Chapter 3.\
When quicktricks win by rank, they are backed up at cutoff termination. \
\
The idea of 
\i QuickTricks 
\i0 is described e.g. in [Chang].\
\

\i LaterTricks
\i0  determines if the opponents of the side to move can take one or more tricks at their turn or later in the play. It is also executed at the beginning of each trick and uses similar criteria for search cutoff as 
\i Quicktricks
\i0 . \
When quicktricks win by rank, they are backed up at cutoff termination.\uc0\u8232 For a detailed description, see Chapter 4.\
\

\i RetrieveTTresult 
\i0 scans the set of positions in the transposition table to see if there is a match against the current position. \
It is executed at the beginning of each trick, before any card has been played. After detection of a  transposition table entry match, the winning ranks necessary in the remaining cards are backed up. \uc0\u8232 For details, see Chapter 7.\
\pard\pardeftab1304

\fs20 \cf0 \
\pard\pardeftab1304

\i\fs24 \cf0 Evaluate  
\i0 returns evalResult which updates the position state information. evalResult contains:\
\pard\tx780\pardeftab1304\li780\fi-360
\ls4\ilvl0
\f2 \cf0 \'a5	
\f1\b evalResult.tricks
\b0 , the number of tricks won by the side of the player, and\
\ls4\ilvl0
\f2 \'a5	
\f1\b evalResult.winRank
\b0  which includes the card in the last trick that won by rank.  \
\pard\pardeftab1304
\cf0 E.g. if the last trick includes the spades A, Q, 9 and 3, evalResult.winRank returns spade A. But\
if the last trick was won without a win by rank as for spade 5 (leading and winning card), heart A, heart Q, heart 5, no winning rank is returned. \
\
Keeping record of cards that win by ranks and subsequently using this information to ignore ranks for other cards is discussed in the Partition Search concept invented by Matthew Ginsberg and described in his paper [Ginsberg]. \
\
\pard\pardeftab1304

\i \cf0 MoveOrdering. 
\i0 The alternative cards created by MoveGenerate are sorted, with the cards most likely to terminate the search fastest being sorted first in the move list.The allocation of card weights are described in detail in Chapter 5.\
\

\i CheckMovesForCutoff 
\i0 checks if any of the moves just generated will lead to a position that can be found in the transposition table. If so, an immediate Search return can be done, saving unnecessary search effort. This is further described in Chapter 6.\
\
To my knowledge this is not described anywhere for usage in a DDS. It is described in [Plaat et al.] and named Enhanced Transposition Cutoffs.\
\
At move search cutoff,
\i  MergeMoveData 
\i0 collects the union of the backed up accumulated winning ranks and the rank of the made move, assuming it did win by rank. The state data of the position is updated with the collected information.\
\

\i MergeAllMovesData 
\i0 collects the union of the backed up accumulated winning ranks, the previous accumulated winning ranks of the alternative moves generated on this depth, and the rank of the made move, assuming it did win by rank. When all alternative moves have been searched without a cutoff, the state data of the position is updated with the collected information.\
\
The information from 
\i MergeMoveData
\i0  and 
\i MergeAllMovesData
\i0  is later stored in the transposition table and determines which ranks that are essential when 
\i RetrieveTTresult
\i0  scans the set of positions in the transposition table. A match of ranks with the current position is only needed for winning ranks. See Chapter 7.\cf3 \strike \strikec3 \
\pard\pardeftab1304
\cf0 \strike0\striked0 \
\pard\pardeftab1304

\i \cf0 AddNewTTentry 
\i0 adds the evaluated position as a new entry in the transposition table. See Chapter 7.\
\

\i NextMove 
\i0 filters out all \'94small\'94 cards except one per hand/suit combination. A \'94small\'94 card is a backed up card that is shown to never win by rank. The rest of the \'94small\'94 card moves for the hand/suit combination are never searched, leading to a smaller search tree.\uc0\u8232 This search enhancement was suggested by Hans Kuijf [Kuijf]. \
\
\
\
\pard\tx0\pardeftab1304
\ls5\ilvl0
\b \cf0 3.	The Quick Tricks cutoff algorithm\
\pard\pardeftab1304
\cf0 \
\pard\pardeftab1304

\b0 \cf0 The number of tricks that can immediately be taken by the side to play the leading card of the trick consists of:\
\pard\tx360\pardeftab1304\li360\fi-360
\ls6\ilvl0\cf0 The number of tricks that can be taken by the hand-to-play, and\
The number of tricks that can be taken by the partner of the hand-to-play\
\pard\pardeftab1304
\cf0 At return by 
\i QuickTricks
\i0 , the position state information is updated with the winning ranks found. \
\
Of course, in order to add b), there must be an entry from the hand-to-play to the partner\'92s hand.\
\
For each \'94s\'94 (suit) the following is calculated:\
\
If the hand-to-play is the only hand having cards in s, and the opponents have no trumps (when s is not trumps), the number of quick tricks for s is the suit length of the hand-to-play.\
\
If the opponents have no trumps, a check is made to see if quick tricks equal to the maximum of the trumps length for leading hand and the partner causes a search cutoff.\
\
If the hand-to-play has a card in a suit where the partner has a winning rank, and partner is the only hand having cards in s:\
The number of quick tricks for s is the suit length of partner.\
\
Else:\
If the winning rank is in hand-to-play, and the opponents cannot ruff, the number of quick tricks is incremented by one. Further, if the second best rank is also in hand-to-play, and the opponents cannot still ruff, the quick tricks is again incremented by one.\
\
Else:\
If the winning rank is in partner and partner has winning rank as entry, the same applies for the partner as for the hand-to-play described above.\
\
If it is a trump contract, the first suit to be investigated is the trump suit. Then if there are trump suit quick tricks for the side to play, those are cashed and quick tricks incremented accordingly.\
\uc0\u8232 When the other suits are investigated for quick tricks, only the remaining opponent trump cards need to be considered.\u8232 \
The quick tricks are then summarized from each suit, and the total calculated.\
\
A simple Quick Tricks algorithm is also executed after the leading card of the trick has been played:\
\
A quick trick is gained either if the hand-to-play or the partner can win the current trick with the card having the highest rank of the suit played, or if hand-to-play or the partner can win the trick by ruffing.\
\
The idea to also execute Quick Tricks after the leading card has been played was given by Hans Kuijf [Kuijf].\
\
\
\
\pard\tx0\pardeftab1304
\ls7\ilvl0
\b \cf0 4.	The Later Tricks cutoff algorithm
\b0  \
\pard\pardeftab1304
\cf0 \
Check for search cutoff if the opponents to the trick leading hand have at least a sure trick later. \
\
\pard\pardeftab1304

\b \cf0 If not trump contract:\uc0\u8232 \
\pard\tx360\pardeftab1304\li360\fi-360
\ls8\ilvl0
\b0 \cf0 The opponents have at least a sure trick if for all suits where the trick leading hand has a card, the side of the leading hand does not have the highest rank.\uc0\u8232 More than one sure trick can be taken by the opponents if they possess the winning rank for more than one suit, or\u8232 \
Assume that all suits where the side of the trick leading hand has the winning rank give maximum possible number of tricks, i.e. that the sure trick number is the sum of the\uc0\u8232 maximum lengths of these suits.\u8232 If this still cannot cause a cutoff for the trick leading side, allocate one sure trick for the opponents side.   \
\pard\pardeftab1304
\cf0 \
\pard\pardeftab1304

\b \cf0 If trump contract:\
\pard\pardeftab1304

\b0 \cf0 \
Quick tricks for the opponents of the leading hand are added when the opponents have one or more winning trumps. This idea was given by Pedja Stanojevic [Stanojevic].\uc0\u8232 \u8232 1)   If the opponent side have all the trumps, the number of sure tricks is the maximum suit length\u8232       length, or\u8232 \
2)   If the opponent side has the highest trump, they have 1 sure trick. If they also have the second\uc0\u8232       highest trump, they have 2 sure tricks, or\u8232 \u8232 3)  If the opponent side has the second highest trump plus at least one trump more behind the \u8232      hand with the highest trump, the opponent side has 1 sure trick.\
\page \
\pard\tx0\pardeftab1304
\ls9\ilvl0
\b \cf0 5.	The Move Ordering algorithm\
\pard\pardeftab1304
\cf0 \
\pard\pardeftab1304

\b0 \cf0 The weight of a card in the move list is affected by the suit and the rank of the card and by the other cards in the same trick.\
The weights of the cards in the move list are used to sort them, with the cards having the highest weight being sorted first in the list. \
\
If the hand-to-play is trick leading hand or void in the suit played by leading hand, the card with the highest weight for each present suit will get a high additional bonus weight. After list resorting, those cards will occupy the first positions in the move list.\
\
Two "best moves" are maintained for each searched depth, one for an alpha-beta cutoff and one at a Transposition Table entry match. At an alpha-beta cutoff, the move causing the cutoff overwrites the present "best move" for the current depth. When a Transposition Table entry is created, the current best move is stored in that entry if:\
The target is met and the leading hand belongs to the player\'92s side, or target is not met and the leading hand belongs to the other side. Otherwise the best move is not stored in the Transposition Table entry. \
At a Transposition Table entry match, its stored best move will be best move for the current search depth.\
\
By \'94card move\'94 in the following pseudo code is meant the card by the hand-to-play that is getting a weight in the move list. The \'94card rank\'94 is a value in the range 2-14, corresponding to the card ranks 2 to the Ace. \
\
For the determination of the weight, it is calculated whether or not the current card move is a card that wins the current trick for the side of the hand-to-play, assuming that both sides play their optimum cards. \
\
If the hand-to-play is void in the trick lead suit, the suit selected for the discard gets the following\uc0\u8232 bonus:\
\
suitAdd = ((suit length) * 64)/36;\
\
If the suit length is 2, and the hand-to-play has the next highest rank of the suit, the bonus \uc0\u8232 (suitAdd) is subtracted by 2. \
\pard\pardeftab1304

\fs20 \cf0 \
\
\pard\pardeftab1304

\fs24 \cf0 \ul \ulc0 Hand-to-play is trick leading hand\
\pard\pardeftab1304
\cf0 \ulnone \
The contribution of the suit to the weight:\
 \
suitWeightDelta = suitBonus \'96 ((countLH+countRH) * 32)/15\
\
suitBonus has the initial value 0, changed if conditions below apply:\
\
If trump contract, and the suit is not trump, then there is a (negative) suitBonus change of  \'9610  if \
\pard\tx360\pardeftab1304\li360\fi-360
\ls10\ilvl0\cf0 LHO is void and LHO has trump card(s), or\
RHO is void and RHO has trump card(s)\
\pard\tx360\pardeftab1304
\cf0 \uc0\u8232 If RHO has either the highest rank of the suit played by hand-to-play or the next highest rank,\
then there is a suitBonus change of \'9618.  \
\
If it is a trump contract, the suit is not trump, own hand has a singleton, own hand has at least one trump, partner has the highest rank in the suit and at least a suit length of 2, then there is a suitBonus change of +16.\
\pard\pardeftab1304
\cf0 \
countLH = (suit length of LHO) * 4, if LHO is not void in the suit,\
countLH = (depth + 4), if LHO is void in the suit\
\
countRH = (suit length of RHO) * 4, if RHO is not void in the suit,\
countRH = (depth + 4), if RHO is void in the suit\
\
Suits are thus favoured where the opponents have as few move alternatives as possible. \
\
\
if (trick winning card move) \{\
    if (one of the opponents has a singleton highest rank in the suit)\
        weight = suitWeightDelta + 40 \'96 (rank of card move)\
    else if (hand-to-play has highest rank in suit)  \{\
        if (partner has second highest rank in suit)\
            weight = suitWeightDelta + 50 \'96 (rank of card move)\
        else if  (the card move is the card with highest rank in the suit)\
            weight = suitWeightDelta + 31\
        else\
            weight = suitWeightDelta + 19 \'96 (rank of card move)\
    \}\
    else if  (partner  has highest rank in suit)  \{\
        if (hand-to-play has second highest rank in suit)\
            weight = suitWeightDelta + 50 \'96 (rank of card move)\
        else\
            weight = suitWeightDelta + 35 \'96 (rank of card move)  \
    \}\
    else if  (hand-to-play has second highest rank together with equivalent card(s) in suit)\
        weight = suitWeightDelta + 40 \
    else\
        weight = suitWeightDelta + 30 \'96 (rank of card move)\
    if  (the card move  is \'94best move\'94 as obtained at alpha-beta cutoff)\
        weight = weight + 52;\
    if  (the card move  is \'94best move\'94 as obtained from a Transposition Table entry match)\
        weight = weight + 11;\
\}\
else \{	/* Not a trick winning move */\
    if  (either LHO or RHO has singleton in suit which has highest rank)\
        weight = suitWeightDelta + 29 \'96 (rank of card move)\
    else if (hand-to-play has highest rank in suit)  \{\
        if (partner has second highest rank in suit)\
            weight = suitWeightDelta + 44 \'96 (rank of card move)\
        else if  (the card move is the card with highest rank in the suit)\
            weight = suitWeightDelta + 25\
        else\
            weight = suitWeightDelta + 13 \'96 (rank of card move)\
    \}\
    else if  (partner  has highest rank in suit)  \{\
        if (hand-to-play has second highest rank in suit)\
            weight = suitWeightDelta + 44 \'96 (rank of card move)\
        else\
            weight = suitWeightDelta + 29 \'96 (rank of card move)  \
    \}\
    else if  (hand-to-play has second highest rank together with equivalent card(s) in suit)\
        weight = suitWeightDelta + 29 \
    else\
        weight = suitWeightDelta + 13 \'96 (rank of card move)\
    if  (the card move  is \'94best move\'94 as obtained at alpha-beta cutoff)\
        weight = weight + 20;\
    if  (the card move  is \'94best move\'94 as obtained from a Transposition Table entry match)\
        weight = weight + 9;\
\}\
\
\
 \ul Hand-to-play is left hand opponent (LHO) to leading hand\
\ulnone \
if (trick winning card move) \{\
    if  (hand-to-play void in the suit played by the leading hand)  \{\
        if  (trump contract and trump is equal to card move suit)\
            weight = 30 - (rank of card move) + suitAdd\
        else\
            weight = 60 - (rank of card move) + suitAdd\
    \}\
    else if (lowest card for partner to leading hand is higher than LHO played card)\
        weight = 45 - (rank of card move)\
    else if (RHO has a card in the leading suit that is higher than the trick leading card\uc0\u8232                but lower than the highest rank of the leading hand)\
        weight = 60 - (rank of card move)\
    else if (LHO played card is higher than card played by the leading hand) \{\
        if (played card by LHO is lower than any card for RHO in the same suit)\
            weight = 75 - (rank of card move)\
        else if (played card by LHO is higher than any card in the same suit for the leading hand)\
            weight = 70 - (rank of card move)\
        else  \{\
            if  (LHO move card has at least one equivalent card) \{\
                weight = 60 - (rank of card move) \
            else\
                weight = 45 - (rank of card move)\
        \}\
    \}\
    else if (RHO is not void in the suit played by the leading hand) \{\
        if  (LHO move card has at least one equivalent card)    \
            weight = 50 - (rank of card move)\
        else\
            weight = 45 - (rank of card move)\
    \}\
    else\
        weight = 45 - (rank of card move)\
\}\
else \{	/* card move is not trick winning */\
    if  (hand-to-play void in the suit played by the leading hand)  \{\
        if  (trump contract and trump is equal to card move suit)\
            weight = 15 - (rank of card move) + suitAdd\
        else\
            weight = - (rank of card move) + suitAdd\
    \}\
    else if (lowest card for partner to leading hand or for RHO in the suit played is higher \uc0\u8232                than played card for LHO) \
        weight = - (rank of card move) \
    else if (LHO played card is higher than card played by the leading hand) \{ \
        if  (LHO move card has at least one equivalent card)\
            weight = 20 - (rank of card move) \
         else \
             weight = 10 - (rank of card move)\
     \}  \
     else \
         weight = - (rank of card move)\
\}      \
\
\
\
\pard\pardeftab1304
\cf0 \ul \ulc0 Hand-to-play is partner to trick leading hand\
\pard\pardeftab1304
\cf0 \ulnone \
if (trick winning card move) \{\
    if  (hand-to-play void in the suit played by the leading hand)  \{\
        if (card played by the leading hand is highest so far) \{\
            if (card by hand-to-play is trump and the suit played by the leading hand is not trump) \
                weight = 30 - (rank of card move) + suitAdd\
            else\
                weight = 60 - (rank of card move) + suitAdd\
        \}\
        else if (hand-to-play is on top by ruffing)\
            weight = 70 - (rank of card move) + suitAdd\
        else if (hand-to-play discards a trump but still loses)\
            weight = 15 - (rank of card move) + suitAdd \
        else       \
            weight = 30 - (rank of card move) + suitAdd\
    \}\
    else \
        weight = 60 - (rank of card move) \
\}\
else \{               /* card move is not trick winning */\
    if  (hand-to-play void in the suit played by the leading hand)  \{\
        if (hand-to-play is on top by ruffing)\
            weight = 40 - (rank of card move) + suitAdd\
        else if (hand-to-play underruffs */\
            weight = -15 - (rank of card move) + suitAdd\
        else\
            weight = - (rank of card move) + suitAdd\
    \}\
    else \{\
         if (the card by hand-to-play is highest so far) \{\
             if (rank of played card is second highest in the suit)\
                weight = 25  \
             else if (hand-to-play card has at least one equivalent card)\
                 weight = 20 - (rank of card move)\
             else\
                 weight = 10 - (rank of card move)\
         \}\
         else\
             weight = -10 - (rank of card move)\
    \}\
\}\
\
\pard\pardeftab1304
\cf0 \ul \ulc0 Hand-to-play is right hand opponent (RHO) to leading hand\
\
\pard\pardeftab1304
\cf0 \ulnone if  (hand-to-play is void in leading suit)  \{\
    if  (LHO has current highest rank of the trick)  \{\
       if  (card move ruffs)\
          weight = 14- (rank of card move) + suitAdd\
       else\
          weight = 30- (rank of card move) + suitAdd \
\pard\pardeftab1304

\fs20 \cf0      \}\
\pard\pardeftab1304

\fs24 \cf0     else if  (hand-to-play ruffs and wins) \
\pard\pardeftab1304

\fs20 \cf0          
\fs24 weight = 30- (rank of card move) + suitAdd\
    else if  (card move suit is trump, but not winning)\
        weight = - (rank of card move)\
    else\
        weight = 14- (rank of card move) + suitAdd\
\}\
else if  (LHO has current winning move)  \{\
    if  (RHO ruffs LHO\'92s winner)\
        weight = 24 - (rank of card move) \
    else\
        weight = 30- (rank of card move) \
\}\
else if  (card move superior to present winning move not by LHO)  \{        
\fs20 \
     
\fs24 weight = 30- (rank of card move)\
else  \{\
    if  (card move ruffs but still losing)\
        weight = - (rank of card move)\
    else\
        weight = 14- (rank of card move)\
\}
\fs20 \
\pard\pardeftab1304

\fs24 \cf0 \
\pard\pardeftab1304\fi1304
\cf0 \
\page \
\pard\tx0\pardeftab1304
\ls11\ilvl0
\b \cf0 6.	Algorithm to try early cutoff for generated moves\
\pard\pardeftab1304
\cf0 \
\pard\pardeftab1304

\b0 \cf0 After generating moves at the end of a trick, they are each checked to see if one of them will lead to a position that already is stored in the Transposition Table.\
Due to the processing overhead, this check is only made if the depth is 33 or more (i.e there are at least 33 cards in the position). \
Pseudo code:\
\
moveExists = TRUE;\
while  (moveExists)  \{\
     Make;\
     depth = depth \'961;\
     RetrieveTTresult;\
     if (hit in the transposition table)  \{\
          Search returnsTRUE if value of the position is TRUE and player side to move, or \
          FALSE if value of the position is FALSE and opponents side to move.  \
          Else: Increment weight of move with 100.  \
      \}\
       depth = depth +1;\
       Undo;\
       moveExists = NextMove;\
\}\
    \
The performance improvement for this enhancement is less than for the other enhancements. The number of generated nodes is roughly decreased by 10% and the search time is slighly decreased.\
\
\
\
\pard\tx0\pardeftab1304
\ls12\ilvl0
\b \cf0 7.	Storage and retrieval of position state data in the Transposition Table\
\pard\tx360\pardeftab1304

\b0 \cf0  
\b \uc0\u8232 
\b0 Positions stored in the Transposition Table always consist of completed tricks. Positions stored start at depth=4, then 8,12, and so on. The information stored is information on won cards, the suit lengths of the hands, the hand to play the leading card in the position and upper and lower bounds for the number of future tricks to be taken by the side of the player.\
\
Starting from issue 1.1.8, each \'94winning cards node\'94 contain all winning cards for one suit after an idea by Jo\'ebl Bradmetz. This new solution is faster.
\b \uc0\u8232 \
\pard\pardeftab1304
\cf0 7.1   Transposition Table storing winning card ranks\
\pard\tx360\pardeftab1304
\cf0 \
\pard\tx360\pardeftab1304

\b0 \cf0 For the outcome of played tricks, only card ranks that are winning due to their ranks matter:\
Assume that the last two tricks of a deal without trumps looks like the following:\
Trick 12: Leading hand North plays heart A, East, South and West follow by hearts Q, 9 and 7 respectively. \
Trick 13: North then leads spade A, the other hands plays diamonds  J, 8,3 in that order.\
\
In trick 12, heart A wins by rank. In trick 13, spade A wins but not by rank.\
The sequence of cards could have been the following without  changing the outcome:\
Trick 12:  heart A, heart x, heart x, heart x\
Trick 13:  spade x, diamond x, diamond x, diamond x\
where x is any rank below lowest winning rank.\
\
The cards that win by rank are recorded during the search and backed up similarly to the search value. If a card wins by rank and there are equivalent cards, e.g. only spade A is searched from a sequence of AKQ, then also the other cards K and Q must be recorded as having won by rank.\
\
The cards winning by rank are stored in the Transposition Table as relative ranks, however any rank larger than the lowest winning rank in the suit are also stored as \'94winning ranks\'94. Using relative ranks rather than absolute ranks considerably increases the number of positions that match this Transposition Table entry:\uc0\u8232 As an example, assume that there are only 4 cards left in a suit, A, Q, 9, 7 where each hand has one card in the suit. Then any combination of ranks, e.g. 8, 6, 3, 2 that preserves the relative order of ranks between hands will cause a match.\
\
In the state position information absolute ranks are used, it is only in the Transposition Table where the ranks are stored as relatives. \
 \
\pard\tx420\pardeftab1304\li420\fi-420

\b \cf0 \
\pard\pardeftab1304
\cf0 7.2  Backing up the winning ranks\
\pard\tx420\pardeftab1304
\cf0 \
\pard\tx420\pardeftab1304

\b0 \cf0 At the search termination, either at the last trick or at a cutoff, the cards that have won by rank are backed up in the search tree together with the search value.\
As this information propagates upwards, it is aggregated  with backed up information from other tree branches.\
At a search cutoff, 
\i MergeMoveData 
\i0 merges the information (V is a union):\
   \
\pard\tx420\pardeftab1304\li420\fi-420
\cf0 (winning ranks of all suits for current depth) = (winning ranks of all suits for depth - 1)  V  (possible winning rank for the current move causing the cutoff)\
\
For each new move not causing cutoff, 
\i MergeAllMovesData 
\i0 merges:\
\
(winning ranks of all suits for current depth) = (winning ranks of all suits for current depth)  V (winning ranks of all suits for depth - 1)  V  (possible winning rank for the current move) \
\pard\tx420\pardeftab1304
\cf0 \
\pard\tx420\pardeftab1304\li420\fi-420

\b \cf0 \
7.3	Checking the current position for a Transposition Table entry match \
\
\pard\tx420\pardeftab1304

\b0 \cf0 The "Transposition Table" has a tree structure rather than a table, consisting of 2 interconnected trees. \
For deciding if there is a match, input is the position state data, including the cards left to play and the current leading hand. \
There are \'94root pointers\'94 per number of tricks left and per leading hand which  each points to the root of a tree of  \'94suit lengths combination\'94 nodes. Each such node includes a 64-bit code that uniquely defines one combination of suit lengths for the hands. The nodes are ordered such that the value of the 64-bit code in a parent node is higher than the 64-bit code of its left child but lower than the 64-bit code of its right child. So to find the node with the suit lengths combination for the actual position, a binary search is made. The basic binary search algorithm is described in [Knuth]. \
Each \'94suit length combination node\'94 points to the root of a tree consisting of \'94winning cards nodes\'94, ie. cards that win by rank. (So the Transposition Table is really a number of trees, a forest.)\
When a position is checked for a possible Transposition Table match, a tree branch is selected consisting of 4 subsequent \'94winning cards nodes\'94, each \'94winning cards node\'94 includes an aggregate of all winning cards for one suit. This branch is followed as long as the \'94winning cards\'94 also can be found in the current position. (Note that the ranks of the \'94winning card nodes\'94 are relative, so the ranks of the current position must first be translated from absolute to relative ranks.)  When the \'94winning cards node\'94 no longer matches with the current position and there is no other alternative \'94winning cards node\'94 that fits, then the search backs up and tries an alternative \'94winning cards node\'94 on a higher level. \
\uc0\u8232 When the last of the 4 subsequent \'94winning cards nodes\'94 containing clubs is reached, it points to a \'94set of positions node\'94. Its stored upper and lower value bounds are checked against the number of tricks won so far by the player\'92s side and the target value. The following conditions are then checked, assuming that it is the North/South side that is the player\'92s side: \
\
If the sum of the stored lower value bound and the number of tricks won so far for the player\'92s side is equal or larger than target, then target can be reached for the player\'92s side in the current position. Search on this depth is terminated and TRUE is returned.\
\
If the sum of the stored upper value bound and the number of tricks won so far for the player\'92s side is less than target, then reaching target can be prevented by the opponents to the player\'92s side in the current position. Search on this depth is terminated and FALSE is returned.\
\
If instead it is East/West that is the player\'92s side, the following conditions apply:\
\
If the sum of number of tricks remaining and the number of tricks won so far for the player\'92s side minus the upper value bound is equal or larger than target, then target can be reached for the player\'92s side in the current position. Search on this depth is terminated and TRUE is returned.\
\
If the sum of number of tricks remaining and the number of tricks won so far for the player\'92s side minus the lower value bound is less than target, then reaching target can be prevented by the opponents to the player\'92s side in the current position. Search on this depth is terminated and FALSE is returned.\
\
For all other cases, the search continues for the current depth.\
\
For example, take the previous example with 2 tricks remaining with spade rank order 1 at North. (Rank order 1 is highest rank.) The hearts have rank orders 1 at North, 2 at East, 3 at South and 4 at West.  The diamond rank orders are orders 1 at East, 2 at South and 3 at West.  North is leading hand.\
The \'94root pointer\'94 is now defined by the number of tricks remaining (=2) and North as leading hand.\
The \'94root pointer\'94 points to the root node of its \'94suit lengths combination\'94 tree. The 64-bit integer coded from the suit lengths for all suits and hands is now searched within the tree. When the node is found with matching 64-bit suit lengths code, this node will point to the root of its \'94winning card\'94 tree.\
This pointer points to a "winning cards node" containing spade rank order 1 at North which fits with the current position. This \'94winning cards node\'94 points to another "winning cards node" containing hearts rank orders 1 at North and 2 at East  which also fits the current position. Next \'94winning cards node\'94 pointed to contains diamonds order 1 at South, which does not match the current position. However, there is an alternative \'94winning cards node\'94 that has diamonds order 1 at East, which fits. (If there had been no alternative \'94winning cards node\'94 which fitted, the search had backed up to the previous \'94winning cards node\'94 to see if there was an alternative \'94winning cards node\'94 on this level which also fitted.) The next \'94winning cards node\'94 pointed to is for clubs. This node is empty, which fits the current position which have no clubs. \
This \'94winning cards node\'94 points to a "set of positions node\'94 which have upper and lower value bounds defined. The conditions for these bounds are assumed to be fulfilled causing search termination on this depth, as described earlier. \
\
The usage of upper and lower value bounds in transposition tables is described in [Chang] and [Kupferschmid, Helmert].
\b \
\pard\pardeftab1304
\cf0 \
\
\pard\pardeftab1304

\b0 \cf0 \
The \'94suit lengths combination\'94 node includes:\
\pard\tx360\pardeftab1304\li360\fi-360
\ls13\ilvl0\cf0       The suit lengths combination as a 64-bit integer.\
      A pointer to the top \'94winning cards node\'94.\
      A pointer to next left \'94suit lengths combination node\'94 in the binary tree.\
      A pointer to next right \'94suit lengths combination node\'94 in the binary tree.\
\pard\pardeftab1304
\cf0 \
\
The \'94winning cards node\'94 includes:\
\pard\pardeftab1304\li720\fi-720
\ls14\ilvl0\cf0 The hands of the relative ranks for each winning card of the actual suit.\
A pointer to the next winning cards node required to achieve a Transposition Table match for this branch of the tree.\
A pointer to the previous winning cards node.\
A pointer to the next alternative winning cards node that leads to a Transposition Table match in an alternative tree branch.\
\pard\tx360\pardeftab1304\li360\fi-360
\ls15\ilvl0\cf0       A pointer to the "set of positions node". \
\pard\pardeftab1304
\cf0 \
\
The "set of positions node\'94 includes:\
\pard\pardeftab1304\li720\fi-720
\ls16\ilvl0\cf0 An upper and a lower bound for the winning tricks of the North/South side. These values\uc0\u8232 are used to determine whether or not a search cutoff can be done.\
The lowest winning rank per suit, expressed as relative rank.\
The suit and rank for the currently best move.\
\pard\pardeftab1304
\cf0 \
 \
\pard\tx420\pardeftab1304
\cf0 After a Transposition Table match, the current position may later be part of a position that will be stored in the Transposition Table. Therefore, the stored winning ranks in the Transposition Table must be included in the state information of the current position. However, the winning ranks cannot be taken as is, because they are stored as relative ranks which now must be converted to absolute ranks in the current position.\
This is done using the lowest winning relative rank for each suit that is stored in the \'94set of positions\'94 node that gave the Transposition Table match:\
The aggregated set of (absolute) ranks for each suit in the current position is filtered using the stored information on the lowest winning relative rank. The winning ranks for each suit is then the aggregated set with only the number of highest ranks implied by the stored lowest winning relative rank in the \'94set of positions\'94 node.\
E.g. if the aggregated rank set for spades is A J 9 4 2 and lowest winning relative rank is order=2, then winning ranks are A J.\
\pard\pardeftab1304
\cf0 \
\
\pard\tx420\pardeftab1304

\b \cf0 7.4  Building a new entry in the Transposition Table
\b0 \
\
When the value of the current position is known and it is the end of a trick (except the last),  position state information is collected for storage in the Transposition Table. \
The ranks of the backed up winning cards are converted from absolute to relative.\
For each suit, it is determined which winning rank that is lowest. The relative ranks then stored in the new Transposition Table entry are all ranks above and including the lowest rank, filling out any \'94holes\'94 in the ranks that might have been present.\
The trees of the Transposition Table are searched starting from the \'94root pointer\'94 and additional nodes are inserted corresponding to the current position. \
First, the suit lengths of the current position are used to find a \'94suit lengths combination node\'94 or to create a new such node if it does not exist already.\
The next step is to search for a \'94winning card node\'94 that has the \'94suit length combination node\'94 as parent. This \'94winning card node\'94 has then winning cards for spades.\
If no such node yet exists, \'94winning card nodes\'94, one for each suit, are created using the winning cards of the current position. Each such node includes all winning cards for one of the suits. Then, a \'94set of positions\'94 node is created. This node is pointed to from the last created \'94winning card node\'94 created for the winning cards of clubs. \
Otherwise, if there already exists a matching \'94winning card node\'94 with the \'94suit length combination node\'94 as parent, it is checked whether or not the \'94winning card nodes\'94 in a subsequent tree branch already created for hearts, diamonds and clubs also are matched with the current position.\
If such a sequence of nodes can be found, the upper or lower bound in the connected \'94set of positions node\'94 may be updated to allow for an increased number of cutoffs:\
\
If the current  position upper value bound is less than the stored upper value bound, the stored value is updated with the current position value.   \
If the current  position lower value bound is larger than the stored lower value bound, the stored value is updated with the current position value.\
\
In case a matching \'94winning card node\'94 cannot be found, a new \'94winning card node\'94 is created and linked to the last matching node. E.g. if existing \'94winning card nodes\'94 for spades and hearts match the current position, but no node match for diamonds, then a \'94winning cards node\'94 for diamonds is created and linked to the previous \'94winning cards node\'94 for hearts. Then a clubs \'94winning cards node\'94 and a \'94set of positions node\'94 are created.\
\
 \
\pard\pardeftab1304

\b \cf0 \
\
\
References\
\pard\pardeftab1304

\b0 \cf0 \
James Dow Allen:\
Source code for a simple DDS.\
\pard\pardeftab1304
{\field{\*\fldinst{HYPERLINK "%5Cl%20%22_Hlk134153111%22"}}{\fldrslt \cf4 \ul \ulc4 http://freepages.genealogy.rootsweb.com/~jamesdow/Tech/dbldum.htm}}\
\
Matthias Brill:\
DDS algorithms description (in German) and DDS source code.\
\pard\pardeftab1304
{\field{\*\fldinst{HYPERLINK "%5Cl%20%22_Hlk134153080%22"}}{\fldrslt \cf4 \ul \ulc4  http://linux.softpedia.com/get/Science-and-Engineering/Artificial-Intelligence/cddsolve-20055.shtml\cf0 \ulnone  }}\
\
Ming-Sheng Chang:\
DDS algorithms description.\
\pard\pardeftab1304
{\field{\*\fldinst{HYPERLINK "smb://l"}}{\fldrslt \cf0 cs.nyu.edu/web/Research/TechReports/TR1996-725/TR1996-725.ps.gz\
}}\pard\pardeftab1304
\cf0 \
\
Ed Colley:\
DDS source code and DDS executable.\
\pard\pardeftab1304
{\field{\*\fldinst{HYPERLINK "smb://l"}}{\fldrslt \cf4 \ul \ulc4 http://freefinesse.sourceforge.net/}}\
\
Matthew L. Ginsberg:\
DDS algorithms description.\
\pard\pardeftab1304
{\field{\*\fldinst{HYPERLINK "%5Cl%20%22_Hlk134152954%22"}}{\fldrslt \cf4 \ul \ulc4 http://www.cs.cmu.edu/afs/cs/project/jair/pub/volume14/ginsberg01a.pdf}}\
\
Dan Hirschberg:\
DDS algorithms description and DDS executable (MS DOS, cannot run in XP?)\
\pard\pardeftab1304
{\field{\*\fldinst{HYPERLINK "smb://l"}}{\fldrslt \cf4 \ul \ulc4 http://www.ics.uci.edu/~dan/bridge/index.html\
}}\pard\pardeftab1304
\cf0 \
Alexey Slovesnov:\
DDS source code and DDS executable.\
\
Judea Pearl: Asymptotic properties of minimax trees and game search precedures.\uc0\u8232    Artificial Intelligence 14(2):113-138. [Pearl 1980]\
\
Aske Plaat, Jonathan Schaeffer, Wim Pijls and Arie de Bruin:  Exploiting graph properties of game trees. In 
\i Proceedings of the Thirteenth National Conference on Artificial Intelligence
\i0 , pages 234-239, 1996  [Plaat et al.]\
\
Hans Kuijf, personal communication.\
\
Pedja Stanojevic, personal communication.\
\
Knuth: The art of computer programming, Vol. 3, Searching and Sorting, chapter 6.2.2, Algorithm T.\
\
Sebastian Kupferschmid, Malte Helmert: A Skat Player Based on Monte Carlo Simulation.\
\
Jo\'ebl Bradmetz, personal communication.\
http://jibe-bridge.perso.cegetel.net/\
}